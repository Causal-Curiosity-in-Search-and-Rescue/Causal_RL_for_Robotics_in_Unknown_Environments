# -*- coding: utf-8 -*-
"""Increase variables graph.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JNkcCN6pnTAY1H_ZVI0x97zvEfvzy4Jg
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install causalnex
# !pip install cdt

import numpy as np
import pandas as pd
import networkx as nx
from causalnex.structure.notears import from_pandas_lasso
from cdt.metrics import precision_recall, SHD
import matplotlib.pyplot as plt

np.random.seed(42)  # Ensure reproducibility

def generate_data(n_samples, n_nodes):
    """Generates dataset with only two nodes having a causal relationship."""
    # Initialize DataFrame with random values
    data = np.random.rand(n_samples, n_nodes)
    df = pd.DataFrame(data, columns=[f'Node_{i}' for i in range(n_nodes)])

    # Simulate a direct causal relationship: Node_0 influences Node_1
    if n_nodes > 1:
        df['Node_1'] += df['Node_0']

    return df

def generate_true_graph(n_nodes):
    """Generates the true graph structure with only two nodes having a true edge."""
    G = nx.Graph()
    G.add_nodes_from([f'Node_{i}' for i in range(n_nodes)])

    # Adding an edge only between Node_0 and Node_1 to represent their causal relationship
    if n_nodes > 1:
        G.add_edge('Node_0', 'Node_1')

    return G

def calculate_metrics(inferred_graph, true_graph, node_names):
    """Calculates SHD and precision between the true graph and the inferred graph."""
    true_adj_matrix = nx.to_numpy_array(true_graph, nodelist=node_names)
    inferred_adj_matrix = nx.to_numpy_array(inferred_graph, nodelist=node_names)

    shd = SHD(true_adj_matrix, inferred_adj_matrix)
    precision, recall = precision_recall(inferred_adj_matrix.flatten().astype(int), true_adj_matrix.flatten().astype(int))

    return shd, precision

# Parameters for the inference process
w_threshold = 0.8
beta = 0.01
max_iter = 50

node_counts = range(2, 10)  # For simplicity, start with graphs of 2 to 5 nodes
samples_needed_for_precision = []

for node_count in node_counts:
    for n_samples in range(1, 30, 1):  # Increment sample sizes by 10
        precision_values = []
        for _ in range(10):  # Increasing trials for robustness
            df = generate_data(n_samples, node_count)
            sm = from_pandas_lasso(df, w_threshold=w_threshold, beta=beta, max_iter=max_iter)
            inferred_graph = nx.DiGraph()
            inferred_graph.add_nodes_from(df.columns)
            inferred_graph.add_edges_from(sm.edges())

            true_graph = generate_true_graph(node_count)
            node_names = df.columns.tolist()
            shd, precision = calculate_metrics(inferred_graph, true_graph, node_names)
            precision_values.append(precision)

        if np.mean(precision_values) >= 0.75:
            samples_needed_for_precision.append((node_count, n_samples))
            break

# Plotting
plt.figure(figsize=(10, 6))
node_counts, samples_needed = zip(*samples_needed_for_precision)
plt.plot(node_counts, samples_needed, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Nodes')
plt.ylabel('Minimum Samples Needed for 75% Precision')
plt.title('Sample Size Requirement for 75% Precision by Node Count')
plt.grid(True)
plt.show()

import numpy as np
import pandas as pd
import networkx as nx
from causalnex.structure.notears import from_pandas_lasso
from cdt.metrics import precision_recall, SHD
import matplotlib.pyplot as plt

np.random.seed(42)  # Ensure reproducibility

def generate_data(n_samples, n_nodes):
    """Generates dataset with only two nodes having a causal relationship."""
    # Initialize DataFrame with random values
    data = np.random.rand(n_samples, n_nodes)
    df = pd.DataFrame(data, columns=[f'Node_{i}' for i in range(n_nodes)])

    # Simulate a direct causal relationship: Node_0 influences Node_1
    if n_nodes > 1:
        df['Node_1'] += df['Node_0']

    return df

def generate_true_graph(n_nodes):
    """Generates the true graph structure with only two nodes having a true edge."""
    G = nx.Graph()  # Changed to Graph for consistency in comparison
    G.add_nodes_from([f'Node_{i}' for i in range(n_nodes)])

    # Adding an edge only between Node_0 and Node_1 to represent their causal relationship
    if n_nodes > 1:
        G.add_edge('Node_0', 'Node_1')

    return G

def calculate_metrics(inferred_graph, true_graph, node_names):
    """Calculates SHD and precision between the true graph and the inferred graph."""
    # Convert inferred graph to undirected graph for comparison
    inferred_graph = inferred_graph.to_undirected()
    true_adj_matrix = nx.to_numpy_array(true_graph, nodelist=node_names)
    inferred_adj_matrix = nx.to_numpy_array(inferred_graph, nodelist=node_names)

    shd = SHD(true_adj_matrix, inferred_adj_matrix)
    precision, recall = precision_recall(inferred_adj_matrix.flatten().astype(int), true_adj_matrix.flatten().astype(int))

    return shd, precision

# Parameters for the inference process
w_threshold = 0.8
beta = 0.01
max_iter = 50

node_counts = range(2, 10)  # For simplicity, start with graphs of 2 to 5 nodes
samples_needed_for_precision = []

for node_count in node_counts:
    for n_samples in range(1, 30, 1):
        precision_values = []
        for _ in range(10):
            df = generate_data(n_samples, node_count)
            sm = from_pandas_lasso(df, w_threshold=w_threshold, beta=beta, max_iter=max_iter)
            inferred_graph = nx.DiGraph()
            inferred_graph.add_nodes_from(df.columns)
            inferred_graph.add_edges_from(sm.edges())

            # Conversion happens in calculate_metrics now, so no need to convert here
            true_graph = generate_true_graph(node_count)
            node_names = df.columns.tolist()
            shd, precision = calculate_metrics(inferred_graph, true_graph, node_names)
            precision_values.append(precision)

        if np.mean(precision_values) >= 0.75:
            samples_needed_for_precision.append((node_count, n_samples))
            break

# Plotting
plt.figure(figsize=(10, 6))
node_counts, samples_needed = zip(*samples_needed_for_precision)
plt.plot(node_counts, samples_needed, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Nodes')
plt.ylabel('Minimum Samples Needed for 75% Precision')
plt.title('Sample Size Requirement for 75% Precision by Node Count')
plt.grid(True)
plt.show()

import numpy as np
import pandas as pd
import networkx as nx
from causalnex.structure.notears import from_pandas_lasso
from cdt.metrics import precision_recall, SHD
import matplotlib.pyplot as plt

np.random.seed(42)  # Ensure reproducibility

def generate_data(n_samples, n_nodes):
    """Generates dataset with only two nodes having a causal relationship."""
    # Initialize DataFrame with random values
    data = np.random.rand(n_samples, n_nodes)
    df = pd.DataFrame(data, columns=[f'Node_{i}' for i in range(n_nodes)])

    # Simulate a direct causal relationship: Node_0 influences Node_1
    if n_nodes > 1:
        df['Node_1'] += df['Node_0']

    return df

def generate_true_graph(n_nodes):
    """Generates the true graph structure with only two nodes having a true edge."""
    G = nx.Graph()  # Changed to Graph for consistency in comparison
    G.add_nodes_from([f'Node_{i}' for i in range(n_nodes)])

    # Adding an edge only between Node_0 and Node_1 to represent their causal relationship
    if n_nodes > 1:
        G.add_edge('Node_0', 'Node_1')

    return G

def calculate_metrics(inferred_graph, true_graph, node_names):
    """Calculates SHD and precision between the true graph and the inferred graph."""
    # Convert inferred graph to undirected graph for comparison
    inferred_graph = inferred_graph.to_undirected()
    true_adj_matrix = nx.to_numpy_array(true_graph, nodelist=node_names)
    inferred_adj_matrix = nx.to_numpy_array(inferred_graph, nodelist=node_names)

    shd = SHD(true_adj_matrix, inferred_adj_matrix)
    precision, recall = precision_recall(inferred_adj_matrix.flatten().astype(int), true_adj_matrix.flatten().astype(int))

    return shd, precision

# Parameters for the inference process
w_threshold = 0.8
beta = 0.01
max_iter = 50

node_counts = range(2, 20)  # For simplicity, start with graphs of 2 to 5 nodes
samples_needed_for_precision = []

for node_count in node_counts:
    for n_samples in range(1, 30, 1):
        precision_values = []
        for _ in range(10):
            df = generate_data(n_samples, node_count)
            sm = from_pandas_lasso(df, w_threshold=w_threshold, beta=beta, max_iter=max_iter)
            inferred_graph = nx.DiGraph()
            inferred_graph.add_nodes_from(df.columns)
            inferred_graph.add_edges_from(sm.edges())

            # Conversion happens in calculate_metrics now, so no need to convert here
            true_graph = generate_true_graph(node_count)
            node_names = df.columns.tolist()
            shd, precision = calculate_metrics(inferred_graph, true_graph, node_names)
            precision_values.append(precision)

        if np.mean(precision_values) >= 0.9:
            samples_needed_for_precision.append((node_count, n_samples))
            break

# Plotting
plt.figure(figsize=(10, 6))
node_counts, samples_needed = zip(*samples_needed_for_precision)
plt.plot(node_counts, samples_needed, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Nodes')
plt.ylabel('Minimum Samples Needed for 90% Precision')
plt.title('Sample Size Requirement for 90% Precision by Node Count')
plt.grid(True)
plt.show()